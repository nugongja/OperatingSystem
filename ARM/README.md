# 1. 리셋 벡터
ARM코어에 전원이 들어가면 ARM 코어가 가장 먼저 하는 일 -> 리셋 벡터에 있는 명령어를 실행함
- 리셋 벡터 :메모리 주소 0x00000000
- 0x00000000에서 32비트를 읽어서 그 명령어를 실행함
- .text : text섹션
- .code 32 : 명령어의 크기가 32bit
- .global : C언어에서의 extern과 같음 -> 변수의 정보를 외부 파일에서 심벌로 읽을 수 있음

# 2. 컴파일
- arm-none-eabi-as ~ : arm-none-eabi 컴파러일러의 소스 파일 컴파일 명령어
    - -march=armv7-a : 아키텍쳐
    - -mcpu=cortex-a8 : RealViewPB(emulator)가 사용하는 ARM코어가 cortex-a8임
    - **.o파일이 나옴** -> ELF(Executable and Linkable Format)형식임
    - **ELF(Executable and Linkable Format) 란?** : 리눅스 기반 시스템의 기본 바이너리 형식임
        - 실행 가능한 바이너리 파일, 목적 파일, 공유 라이브러리, 코어 덤프 등에서 사용되는 형식이다.  
        - 실행 가능한 바이너리 코드뿐만 아니라 심볼 테이블, 디버깅 정보, 섹션 헤더 등의 추가적인 메타데이터를 포함하는 파일 형식임
- arm-none-ebai-objcopy : 바이너리만 뽑아냄
    - .o파일은 심벌 정보 등이 포함되어있음. 하지만 임베디드 환경에서는 이러한ELF 형식이 필요하지 않고, 순수한 바이너리 코드만 필요할 수 있음 
    - objcopy를 사용하면 필요한 부분만 추출 가능 
    - 바이너리만 뽑아내려면 -O binary옵션으로 바이너리를 카피해야 함
    - hexdump 명령어로 바이너리 확인 가능

# 3. 실행 파일 만들기
- ELF파일을 만들려면 링커의 도움이 필요하다. 
- **linker** :  여러 오브젝트 파일을 묶어서 하나의 실행 파일로 만드는 프로그램
    - 링커가 동작하려면 링커에 정보를 던져주는 파일이 필요한데, 그걸 **링커 스크립트**라고 함. (.ld)
    - 일반적인 애플리케이션 개발에서는 링커를 신경쓰지 않음
        - 운영체제가 자동으로 메모리를 관리함
        - 링커가 자동으로 적절한 설정을 사용함
        - OS의 Loader가 실행 시점에 필요한 라이브러리를 적절한 메모리에 배치하고 연결해줌
        => 즉, 개발자가 직접 링커 스크립트를 수정할 필요가 없음 
    - 임베디드 환경에서는 운영체제가 없거나 제한적이므로, 코드와 데이터를 정확한 메모리 위치에 배치해야 함
        - 메모리 배치를 수동으로 설정해야
        - RAM이 제한적이므로 스택과 힙을함 최적 배치해야함
- arm-none-eabi-ld : 실행 파일 만드는 명령어(.ld와 .o를 사용)
    - -n : 링커에 섹션의 정렬을 자동으로 맞추지 말라고 지시하는 옵 션  
    - -T : 링커 스크립트의 파일명을 알려주는 옵션
    - -nostdlib : 링커가 자동으로 표준 라이브러리를 링킹하지 못하도록 짓하는 옵션
    - **링커가 동작을 완료하면 .axf파일이 생성됨**

# 4. 실행하기
- ./navilos.axf 하면 Format error : 리눅스 커널에서 동작하지 않는 섹션 배치로 만들어져있기 때문 
- 실행 방법 1 : ARM 개발 보드에 다운로드해서 동작을 확인
- 실행 방법 2: QEMU로 실행
    - qemu-system-arm -M realview-pb-a8 -kernel navilos.axf -S -gdb tcp::1234
        - -S -gdb tcp::1234 -> 옵션은 gdb와 연결하는 소켓 포트를 지정하는 옵션
        - qemu로 실행하면 화면에 아무것도 나오지 않기 때문에 오류라고 착각할 수 있음 -> gdb를 통해 메모리를 확인해야함
        - arm-none-eabi-gdb 를 설치하면 gdb-multiarch가 대신 다운로드됨 -> 아마 arm-none-eabi-gdb는 더이상 안쓰이는 듯?
            - gdb-multiarch 실행 후, target remote localhost:소켓번호
        - x/4x 0 : 0x00000000 메모리 주소에서 4바이트 출력
            - 결과가 나오면 navilos.axf파일에 있는 코드 데이터가 QEMU의 메모리로 제대로 다운로드 되었다는 뜻!

# 빌드 자동화하기
실행 파일을 만들기 위해서는 arm-none-eabi-as로 컴파일 한 뒤, arm-none-eabi-ld로 링킹을 해야 함
- 만약 어셈블리 파일이 하나 더 생기면 arm-none-eabi-as를 한 번 더 한 뒤, arm-none-eabi-ld에 입력 파일명을 추가해 줘야하기 때문에 매우 귀찮음
**=> Makefile을 만들어서 빌드 자동화!**

# 하드웨어 정보 읽어오기 - 데이터시트
하드웨어와 상호작용 한다 = 하드웨어에서 정보를 일고오고, 하드웨어에 정보를 쓰는 작업을 한다.
-> 레지스터를 이용!: 하드웨어가 소프트웨어와 상호작용하는 인터페이스
- 펌웨어를 개발할 때, 해당 하드웨어의 레지스터 사용법을 알아야 하고, 하드웨어의 레지스터 사용법은 데이터 시트에 나와있음. 
    - **데이터 시트**: 해당 하드웨어가 가지고 있는 레지스터의 목록과 설명, 그리고 레지스터에 어떤 값을 썼을 때 하드웨어가 어떻게 동작하는지를 적어 놓은 문서.
    - 레지스터에 대한 예제를 제공하는 **Application Note**라는 것도 있음. 
