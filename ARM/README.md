# chapter 3

## 1. 리셋 벡터
ARM코어에 전원이 들어가면 ARM 코어가 가장 먼저 하는 일 -> 리셋 벡터에 있는 명령어를 실행함
- 리셋 벡터 :메모리 주소 0x00000000
- 0x00000000에서 32비트를 읽어서 그 명령어를 실행함
- .text : text섹션
- .code 32 : 명령어의 크기가 32bit
- .global : C언어에서의 extern과 같음 -> 변수의 정보를 외부 파일에서 심벌로 읽을 수 있음
</br>

## 2. 컴파일
- arm-none-eabi-as ~ : arm-none-eabi 컴파러일러의 소스 파일 컴파일 명령어
    - -march=armv7-a : 아키텍쳐
    - -mcpu=cortex-a8 : RealViewPB(emulator)가 사용하는 ARM코어가 cortex-a8임
    - **.o파일이 나옴** -> ELF(Executable and Linkable Format)형식임
    - **ELF(Executable and Linkable Format) 란?** : 리눅스 기반 시스템의 기본 바이너리 형식임
        - 실행 가능한 바이너리 파일, 목적 파일, 공유 라이브러리, 코어 덤프 등에서 사용되는 형식이다.  
        - 실행 가능한 바이너리 코드뿐만 아니라 심볼 테이블, 디버깅 정보, 섹션 헤더 등의 추가적인 메타데이터를 포함하는 파일 형식임
- arm-none-ebai-objcopy : 바이너리만 뽑아냄
    - .o파일은 심벌 정보 등이 포함되어있음. 하지만 임베디드 환경에서는 이러한ELF 형식이 필요하지 않고, 순수한 바이너리 코드만 필요할 수 있음 
    - objcopy를 사용하면 필요한 부분만 추출 가능 
    - 바이너리만 뽑아내려면 -O binary옵션으로 바이너리를 카피해야 함
    - hexdump 명령어로 바이너리 확인 가능
</br>

## 3. 실행 파일 만들기
- ELF파일을 만들려면 링커의 도움이 필요하다. 
- **linker** :  여러 오브젝트 파일을 묶어서 하나의 실행 파일로 만드는 프로그램
    - 링커가 동작하려면 링커에 정보를 던져주는 파일이 필요한데, 그걸 **링커 스크립트**라고 함. (.ld)
    - 일반적인 애플리케이션 개발에서는 링커를 신경쓰지 않음
        - 운영체제가 자동으로 메모리를 관리함
        - 링커가 자동으로 적절한 설정을 사용함
        - OS의 Loader가 실행 시점에 필요한 라이브러리를 적절한 메모리에 배치하고 연결해줌
        => 즉, 개발자가 직접 링커 스크립트를 수정할 필요가 없음 
    - 임베디드 환경에서는 운영체제가 없거나 제한적이므로, 코드와 데이터를 정확한 메모리 위치에 배치해야 함
        - 메모리 배치를 수동으로 설정해야
        - RAM이 제한적이므로 스택과 힙을함 최적 배치해야함
- arm-none-eabi-ld : 실행 파일 만드는 명령어(.ld와 .o를 사용)
    - -n : 링커에 섹션의 정렬을 자동으로 맞추지 말라고 지시하는 옵 션  
    - -T : 링커 스크립트의 파일명을 알려주는 옵션
    - -nostdlib : 링커가 자동으로 표준 라이브러리를 링킹하지 못하도록 짓하는 옵션
    - **링커가 동작을 완료하면 .axf파일이 생성됨**
</br>

## 4. 실행하기
- ./navilos.axf 하면 Format error : 리눅스 커널에서 동작하지 않는 섹션 배치로 만들어져있기 때문 
- 실행 방법 1 : ARM 개발 보드에 다운로드해서 동작을 확인
- 실행 방법 2: QEMU로 실행
    - qemu-system-arm -M realview-pb-a8 -kernel navilos.axf -S -gdb tcp::1234
        - -S -gdb tcp::1234 -> 옵션은 gdb와 연결하는 소켓 포트를 지정하는 옵션
        - qemu로 실행하면 화면에 아무것도 나오지 않기 때문에 오류라고 착각할 수 있음 -> gdb를 통해 메모리를 확인해야함
        - arm-none-eabi-gdb 를 설치하면 gdb-multiarch가 대신 다운로드됨 -> 아마 arm-none-eabi-gdb는 더이상 안쓰이는 듯?
            - gdb-multiarch 실행 후, target remote localhost:소켓번호
        - x/4x 0 : 0x00000000 메모리 주소에서 4바이트 출력
            - 결과가 나오면 navilos.axf파일에 있는 코드 데이터가 QEMU의 메모리로 제대로 다운로드 되었다는 뜻!
</br>

## ❤️  빌드 자동화하기
실행 파일을 만들기 위해서는 arm-none-eabi-as로 컴파일 한 뒤, arm-none-eabi-ld로 링킹을 해야 함
- 만약 어셈블리 파일이 하나 더 생기면 arm-none-eabi-as를 한 번 더 한 뒤, arm-none-eabi-ld에 입력 파일명을 추가해 줘야하기 때문에 매우 귀찮음
**=> Makefile을 만들어서 빌드 자동화!**
</br>

## ❤  하드웨어 정보 읽어오기 - 데이터시트
하드웨어와 상호작용 한다 = 하드웨어에서 정보를 일고오고, 하드웨어에 정보를 쓰는 작업을 한다.
-> 레지스터를 이용!: 하드웨어가 소프트웨어와 상호작용하는 인터페이스
- 펌웨어를 개발할 때, 해당 하드웨어의 레지스터 사용법을 알아야 하고, 하드웨어의 레지스터 사용법은 데이터 시트에 나와있음. 
    - **데이터 시트**: 해당 하드웨어가 가지고 있는 레지스터의 목록과 설명, 그리고 레지스터에 어떤 값을 썼을 때 하드웨어가 어떻게 동작하는지를 적어 놓은 문서.
    - 레지스터에 대한 예제를 제공하는 **Application Note**라는 것도 있음. 

-----------------------------------------------------------------------------------
# chapter 4 (부팅하기)
**팜웨어에서의 부팅** : 시스템에 전원이 들어가서 모든 초기화 작업을 마치고 펌웨어가 idle상태가 되 때까지를 말하거나, 시스템에 전원이 들어가고 ARM 코어가 리셋 익셉션 핸들러를 모두 처리한 다음에 본격적으로 C언어 코드로 넘어가기 직전을 말함.

## 1. 메모리 설계 
실행파일은 메모리를 크게 세 가지로 나누어 사용한다
- text영역 : 코드가 있는 공간. 코드이므로 임의로 변경하면 안된다.
- data영역 : 초기화한 전역 변수가 있는 공간. 전역 변수를 선언할 때 초기값을 할당해서 선언하면 해당 전역 변수가 점유하는 공간은 여기에 할당됨.
- BSS영역 : 초기화하지 않은 전역 변수가 있는 공간. 초기화하지 않은 전역변수이므로 빌드 완료되어 생성된 바이너리 파일에는 심벌과 크기만 들어있음.
+ Heap : malloc() 또는 new를 통해 동적으로 할당하는 메모리
+ Stack : 함수 호출 시 지역 변수 및 리턴 주소 저장(task stack) 
- 속도는 빠르지만 작은 메모리와 속도는 느리지만 용량이 큰 메모리가 있다면, text와 일부 속도에 민감한 data영역의 데이터들은 전자에, 나머지 data와 bss의 데이터들은 후자에 배치
- 특히 .data, .bss같은 메모리 영역은 어디에서 사용되는가가 중요하다.
    - 즉, 이 변수들이 사용자 모드(USR)에서 사용되는 것인지, 커널 모드(SVC)에서 사용되는 것인지에 따라 동작 방식이 달라질 수 있다.
    - 예를 들어,
        int global_var = 10; 같은 변수가 .data 영역에 할당되더라도,
        **사용자 프로세스(USR 모드)**에서 실행되면 사용자 영역의 .data를 사용한다.
        **커널 모드(SVC 모드)**에서 실행되면 커널 전용 .data 영역이 따로 할당된다.
    - **ARM 프로세서의 실행 모드** (https://velog.io/@mysprtlty/ARM%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%AA%A8%EB%93%9C)
</br>

## 2. 익셉션 벡터 테이블 만들기
⭐ **Exception Vector Table**: CPU에서 Exceptions나 Interrupts가 발생했을 때, 해당 예외 처리를 할 Handler주소를 저장하는 테이블이다. (예외 발생시 실행될 코드의 시작 주소를 저장해 놓은 공간)
- 전원이 켜지면 ARM은 익셉션 벡터의 리셋 벡터를 읽는다. 
    - 대부분은 ARM이 정한 기본 위치인 0x00000000 메모리 주소에 익셉션 벡터 테이블을 배치함.
- 익셉션은 각각 4바이트씩 -> 익셉션 핸들러로 이동하는 브랜치 명령어를 작성
- exception이 발생하면 PC를 익셉션 벡터 테이블의 익셥센 벡터 오프셋으로 변경 -> 브랜치 명령에 따라 익셉션 핸들러로 진입 -> 익셉션 처리 -> 예외 처리 전 위치로 복귀
    - 익셉션이 발생하면 프로그램 흐름이 다시 원래 위치로 복귀할 수 있도록 ARM에서는 R14(LR)에 복귀할 주소를 자동으로 저장함.
    - 정확히는 예외 처리 다음에 실행할 명령어 위치 **(PC + 4)**
- **CPSR, SPSR**
    - CPSR(Current Program Status Register) : 현재 CPU의 상태를 나타내는 레지스터로, 프로세서의 실행 모드, 인터럽트 상태, 조건 플래그 등을 포함한다.
        - 32비트
        -ex) 31  30  29  28  27       8  7   6   5   4  3  2  1  0
             [N] [Z] [C] [V] [reserved] [I] [F] [T] [M4 M3 M2 M1 M0]
            - M4~M0에서 실행모드를 결정 (USR: 10000, FIQ: 10001, ...) 
    - SPSR(Saved Program Status Register) : 예외 또는 인터럽트가 발생했을 때 CPSR의 값을 저장하는 레지스터이며, 나중에 예외 처리가 끝난 후 원래 상태로 복귀하기 위해 필요함.
        - SPSR이 동작하는 방법
            1. 예외 발생
                - ARM CPU가 예외를 감지하면 현재 실행모드를 변경하고 CPSR을 SPSR에 저장 (R14에 PC+4도 저장함) 
                - 예외 핸들러가 실행
            2. 예외 처리 후 복귀
                - 예외 처리가 끝나면 MOVS 또는 SUBS 명령을 사용하여 SPSR값을 CPSR로 복구.
                - R14 -> PC로 복구.
                - 원래 실행 상태로 돌아감


⭐ 인터럽트 
: 외부 요인에 의해서 발생하는 것!
- 인터럽트는 필연적으로 인터럽트 지연을 발생시킨다. 인터럽트 지연이란, 하드웨어가 인터럽트를 감지해서 ARM에 인터럽트 신호가 입력되는 순간부터 펌웨어에서 인터럽트 핸들러가 수행되기 직전까지 걸리는 시간이다. 
    - 매우 짧은 시간이지만 임베디드 시스템의 목적에 따라서 이 시간이 문제가 되기도 한다.
    => 그래서 벡터 인터럽트 컨트롤러(Vector Interrupt Controller, VIC)등의 별도 하드웨어로 인터럽트 지연을 최대한 줄이려는 여러 시도가 존재함
- ARM은 두 종류의 인터럽트를 제공한다. IRQ, FIQ (그 외에도 NMFI, LIL, IC 등이 존재)
#### 1. IRQ(Interrupt Request)
- IRQ는 FIQ보다 우선순위가 낮으므로 만약 IRQ와 FIQ가 동시에 발생하면 ARM은 FIQ에 대한 처리 요청을 팜웨어에 먼저 보낸다.
- CPSR의 I비트를 1로 설정하면 IRQ익셉션을 비활성화함 (비활성화하면 자동으로 IRQ에 해당하는 모든 인터럽트 요청도 펌웨어로 처리되지 않음)
    
#### 2. FIQ(Fast Interrupt Request)

#### 3. NMFI(None-Maskable Fast Interrupt)
- NMFI를 켜면 FIQ를 비활성화 할 수 없다. 하드웨어가 자동으로 CPSR의 F비트를 0으로 클리어한다. 

#### 4. LIL(Low Interrupt Latency)
- 인터럽트 지연을 줄이기 위한 기능 중 하나로 ARM의 기본 설정 기능이다. 
- LIL은 인터럽트가 발생했을 때 현재 수행중인 명령의 실행이 아직 끝나지 않았더라도 실행 중인 명령어를 취소해버리고 인터럽트를 먼저 처리한다.
- 실행이 끝나지 않은 명령어는 인터럽트 핸들러의 처리가 모두 끝난 다음에 원래 프로그램의 진행 흐름으로 복귀할 때 인터럽트가 발생했던 시점에서 한 명령어 뒤로 다시 돌아가도록 해서 처리한다. -> 같은 명령어를 두 번 실행한다는 뜻이지만, 인터럽트의 지연을 줄일 수 있다.
- ARM은 메모리 타입을 strongly ordered로 설정할 수 있다. Strongly ordered로 설정된 메모리나 장치는 읽기, 쓰기, 동작을 수행한 순서와 횟수를 보장해야하기 때문에, 이 값으로 설정된 메모리나 장치는 메모리 접근을 시작한 후에는 수행이 끝날 때까지 중간에 실행을 멈출 수 없다.  따라서 인터럽트 지연 시간을 최소화하기 위해서는 strongly ordered로 설정된 메모리나 장치에 대해서는 multiword load/store 명령을 되도록 사용하지 않는게 좋음.

#### 5. VIC(Vectored Interrupt Controller)
- VIC를 포함하는 Interrupt Controller는 인터럽트 처리를 전담하는 일종의 주변장치이다. 
- **인터럽트 컨트롤러가 하는 일**      
    - 인터럽트가 발생했을 때 해당 인터럽트의 종류를 레지스터에 기록한다.
    - 인터럽트 발생 시, ARM의 IRQ 혹은 FIQ에 맞춰서 인터럽트 신호를 준다.
    - 특정 인터럽트를 골라서 마스킹할 수 있다.
    - 여러 인터럽트 간에 우선순위를 정할 수 있다.
- VIC의 장점 
    - VIC를 사용하면 다음과 같은 세 단계를 하드웨어가 모두 처리한 다음 곧바로 팜웨어의 인터럽트 서비스 루틴으로 진입한다. (일반적으로는 펌웨어가 세 단계를 처리한 뒤 인터럽트 서비스 루틴으로 진입함)
    1. 인터럽트 컨트롤러에서 인터럽트 소스가 어떤 것인지를 판별한다.
    2. 인터럽트 소스에 따라 실행해야 할 인터럽트 서비스 루틴을 선택한다. (인터럽트 서비스 루틴 != 인터럽트 핸들러 -> 인터럽트 서비스 루틴은 인터럽트 핸들러의 하위 개념!)
    3. 해당 인터럽트 소스를 비활성화하고 인터럽트 서비스 루틴으로 진입한다. 
- VIC는 인터럽트에 대해서 인터럽트 서비스 루틴의 시작 메모리 주소를 직접 저장한다. 물론 주소는 펌웨어가 지정함.
    -> 인터럽트가 발생하면 VIC에 의해서 인터럽트 서비스 루틴으로 PC값이 바뀐다. 
